/*
 * Copyright (c) 2018 Volkswagen AG. All rights reserved.
 *
 * NOTICE: All information contained herein is, and remains the property of Volkswagen AG
 * and its suppliers, if any. The intellectual and technical concepts contained herein
 * are proprietary to Volkswagen AG and its suppliers and may be covered by German and
 * Foreign Patents, patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material strictly forbidden
 * unless prior written permission is obtained from Volkswagen AG.
*/

/***
Protocol Buffers description of the sSOA manifest distribution mechanism's data packets.
Two communication channels are used:
 * UDP multicast or announcing the version of the local Manifest Collection to other participants (SSOA_<ECU>_Data)
 * TCP for providing the Manifest Collection to other participants (TCPServer_SSOA_<ECU>_Data)
Each sSOA ECU has to provide both channels to all other participants.
For example, SSOA_OCU_Version and TCPServer_SSOA_OCU_Data are offered by the OCU and consumed by all other participants.
The protocol flow is described below the data packet definitions.
***/

syntax = "proto2";

package manifest_manager_msg;


/** Cyclical message distributed via UDP multicast **/
message MM_CollectionVersionAnnounce {
  /* Protocol version */
  required uint32 Version = 1;
  /* Manifest Collection version (32 hexadecimal letters) */
  required string CollectionVersion = 2;
}

/** Client request over TCP **/
message MM_ClientRequest_V1 {
  /* Request command to the Server: parrot received Collection Version (32 hexadecimal letters) */
  required string CollectionVersion = 1;
}

/** Server response via TCP **/
message MM_ManifestCollection_V1 {
  /* Manifest Collection version (32 hexadecimal letters) */
  required string CollectionVersion = 1;
  /* Manifests */
  repeated string Manifests = 2;
}

/***
Protocol flow:
 1. Server broadcasts MM_CollectionVersionAnnounce via UDP
 2. Client receives MM_CollectionVersionAnnounce via UDP
 3. Client compares locally cached CollectionVersion for this server with received MM_CollectionVersionAnnounce.CollectionVersion
 4. If versions differ, client connects to Server via TCP
 5. Client sends MM_ClientRequest_V1 with MM_ManifestClientRequest_V1.CollectionVersion = MM_CollectionVersionAnnounce.CollectionVersion to server
 6. If the server sees that MM_ManifestClientRequest_V1.CollectionVersion is not equal to its local manifest collection version then it responds with MM_ManifestCollection_V1 with:
  * MM_ManifestCollection_V1.CollectionVersion = current Manifestcollection version
  * MM_ManifestCollection_V1.Manifests = <empty>
 7. If the server sees that MM_ManifestClientRequest_V1.CollectionVersion is equal to its local manifest collection version then it responds with MM_ManifestCollection_V1 with:
  * MM_ManifestCollection_V1.CollectionVersion = current Manifestcollection version
  * MM_ManifestCollection_V1.Manifests = local Security Manifests
 8. The TCP connection is closed
 8a. If the client receives MM_ManifestClientRequest_V1 with Manifests = <empty>, it may restart at 4 and use the received MM_ManifestCollection_V1.CollectionVersion for a new request
 8b. If the client receives MM_ManifestClientRequest_V1 with Manifests != <empty> it starts processing the received Manifest Collection
***/
