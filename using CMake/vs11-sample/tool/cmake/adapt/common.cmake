#
# CMake common definitions for main project and all sub projects
#

cmake_minimum_required(VERSION 2.8.12)

# name of sln (${this_target} is inherited from including cmake file)
# PROJECT(${this_target}) # needs to be set much earlier

set(CMAKE_USE_RELATIVE_PATHS     True)


# First for the generic no-config case (e.g. with mingw)
set( CMAKE_RUNTIME_OUTPUT_DIRECTORY "${CMAKE_HOME_DIRECTORY}/ide/out/hex/${OUTPUTCONFIG}" )
set( CMAKE_LIBRARY_OUTPUT_DIRECTORY "${CMAKE_HOME_DIRECTORY}/ide/out/hex/${OUTPUTCONFIG}" )
set( CMAKE_ARCHIVE_OUTPUT_DIRECTORY "${CMAKE_HOME_DIRECTORY}/ide/out/hex/${OUTPUTCONFIG}" )
# Second, for multi-config builds (e.g. msvc)
foreach( OUTPUTCONFIG ${CMAKE_CONFIGURATION_TYPES} )
    string( TOUPPER ${OUTPUTCONFIG} OUTPUTCONFIG )
    set( CMAKE_RUNTIME_OUTPUT_DIRECTORY_${OUTPUTCONFIG} "${CMAKE_HOME_DIRECTORY}/ide/out/hex/${OUTPUTCONFIG}" )
    set( CMAKE_LIBRARY_OUTPUT_DIRECTORY_${OUTPUTCONFIG} "${CMAKE_HOME_DIRECTORY}/ide/out/hex/${OUTPUTCONFIG}" )
    set( CMAKE_ARCHIVE_OUTPUT_DIRECTORY_${OUTPUTCONFIG} "${CMAKE_HOME_DIRECTORY}/ide/out/hex/${OUTPUTCONFIG}" )
endforeach( OUTPUTCONFIG CMAKE_CONFIGURATION_TYPES )


# set project short name (used to assign sourcefiles in .cmk)
set(this_target_shortname jcp)


macro(setCCompilerFlag SOURCEFILES)
    foreach(SOURCEFILE ${SOURCEFILES})
        string(REGEX MATCH ".*\\.[cC]$" C_SOURCEFILE ${SOURCEFILE})
        list(APPEND C_SOURCEFILES ${C_SOURCEFILE})
    endforeach(SOURCEFILE)
    set_source_files_properties(${C_SOURCEFILES} PROPERTIES LANGUAGE "C")
endmacro(setCCompilerFlag)

macro(writeExcludeListFile)
    SET(CMAKE_EXCLUDELIST_FILE "tool/cmake/tmp/CMake_ExcludedFiles_gen.txt")
    SET(EXCLUDELIST_SIMU  ${this_target}_FILES_EXCLUDED_SIMU)
    SET(EXCLUDELIST_TGT   ${this_target}_FILES_EXCLUDED_TARGET)
    
    # get relative paths with respect to this_target_dir (list contains absolute paths)
    foreach(MYFILELIST ${EXCLUDELIST_SIMU} ${EXCLUDELIST_TGT})
        foreach(MYFILE ${${MYFILELIST}})
            file(RELATIVE_PATH MYRELPATH ${this_target_dir} ${MYFILE})
            list(APPEND ${MYFILELIST}_REL ${MYRELPATH})
        endforeach(MYFILE)
    endforeach(MYFILELIST)
    
    FILE(WRITE "${CMAKE_EXCLUDELIST_FILE}"
        "# This file is generated by CMake.\n"
        "# It lists files which should be excluded from build in either Debug or Multi2000 configuration.\n"
        "\n"
        "ExcludeFromBuild FileConfiguration=\"Debug|Win32\" FileList=\"${${EXCLUDELIST_SIMU}_REL}\"\n"
        "ExcludeFromBuild FileConfiguration=\"Multi2000|Win32\"  FileList=\"${${EXCLUDELIST_TGT}_REL}\"\n"
    )
endmacro(writeExcludeListFile)


################################################################################
# creating file lists:

###
# get absolute paths of file list
# call: getRealPath(<ListName> <FileList>)
macro(getRealPath MYLIST)
    UNSET(${MYLIST})
    foreach(MYFILE ${ARGN})
        get_filename_component(MYREALPATH ${MYFILE} REALPATH)
        LIST(APPEND ${MYLIST} ${MYREALPATH})
    endforeach(MYFILE)
endmacro()

macro(stripList MYLIST)
    foreach(MYFILE ${ARGN})
        get_filename_component(MYREALPATH ${MYFILE} REALPATH)
        LIST(REMOVE_ITEM ${MYLIST} ${MYREALPATH})
    endforeach(MYFILE)
endmacro()

MACRO(setVSProject)
    SET(activeProjects ${ARGN})
ENDMACRO()

MACRO(setVSFilter VSFILTER)
# use cds_set_folder(<your_folder>) instead
ENDMACRO()

###
# lists of package files
macro(staticFileList)
    LIST(LENGTH activeProjects MYPROJECTSET)
    LIST(FIND activeProjects ${this_target_shortname} MYFILESVALID)
    IF( (${MYPROJECTSET} EQUAL 0) OR (NOT ${MYFILESVALID} EQUAL -1) )
        getRealPath(ABSFILELIST ${ARGN})
        LIST(APPEND ${this_target}_${this_package}_FILES    ${ABSFILELIST})
        LIST(APPEND ${this_target}_SOURCE_FILES             ${ABSFILELIST})
    ENDIF()
endmacro(staticFileList)

macro(generatedFileList)
    LIST(LENGTH activeProjects MYPROJECTSET)
    LIST(FIND activeProjects ${this_target_shortname} MYFILESVALID)
    IF( (${MYPROJECTSET} EQUAL 0) OR (NOT ${MYFILESVALID} EQUAL -1) )
        getRealPath(ABSFILELIST ${ARGN})
        SET_SOURCE_FILES_PROPERTIES(${ABSFILELIST} PROPERTIES GENERATED TRUE)
        LIST(APPEND ${this_target}_${this_package}_FILES_GEN    ${ABSFILELIST})
        LIST(APPEND ${this_target}_SOURCE_FILES                 ${ABSFILELIST})
    ENDIF()
endmacro(generatedFileList)

macro(removeFileFromList)
    # remove file from target source file list, file still exists in package file list!
    stripList(${this_target}_SOURCE_FILES ${ARGN})
endmacro(removeFileFromList)

###
# lists of excluded files
macro(excludeFromBuild)
    LIST(LENGTH activeProjects MYPROJECTSET)
    LIST(FIND activeProjects ${this_target_shortname} MYFILESVALID)
    IF( (${MYPROJECTSET} EQUAL 0) OR (NOT ${MYFILESVALID} EQUAL -1) )
        excludeFromBuildSimulation(${ARGN})
        excludeFromBuildTarget(${ARGN})
    ENDIF()
endmacro(excludeFromBuild)

macro(excludeFromBuildSimulation)
    LIST(LENGTH activeProjects MYPROJECTSET)
    LIST(FIND activeProjects ${this_target_shortname} MYFILESVALID)
    IF( (${MYPROJECTSET} EQUAL 0) OR (NOT ${MYFILESVALID} EQUAL -1) )
        getRealPath(ABSFILELIST ${ARGN})
        LIST(APPEND ${this_target}_${this_package}_FILES_EXCLUDED_SIMU      ${ABSFILELIST})
        LIST(APPEND ${this_target}_FILES_EXCLUDED_SIMU                      ${ABSFILELIST})
    ENDIF()
endmacro(excludeFromBuildSimulation)

macro(excludeFromBuildTarget)
    LIST(LENGTH activeProjects MYPROJECTSET)
    LIST(FIND activeProjects ${this_target_shortname} MYFILESVALID)
    IF( (${MYPROJECTSET} EQUAL 0) OR (NOT ${MYFILESVALID} EQUAL -1) )
        getRealPath(ABSFILELIST ${ARGN})
        LIST(APPEND ${this_target}_${this_package}_FILES_EXCLUDED_TARGET    ${ABSFILELIST})
        LIST(APPEND ${this_target}_FILES_EXCLUDED_TARGET                    ${ABSFILELIST})
    ENDIF()
endmacro(excludeFromBuildTarget)

###
# write target build files for libraries, include paths, definitions
macro(write_target_build_file MYFILE MYFILEVALIDFLAG)
    SET(TARGET_BUILD_FILE "${this_target_dir}/tool/cmake/tmp/${MYFILE}")
    
    # create / clean file from previouse installations
    IF(NOT DEFINED ${MYFILEVALIDFLAG})
        FILE(WRITE "${TARGET_BUILD_FILE}" "# This file is generated by CMake\n# Do changes only in 'CMakeLists.txt' file!\n\n")
        SET(${MYFILEVALIDFLAG} True)
    ENDIF(NOT DEFINED ${MYFILEVALIDFLAG})
    
    # write content to file
    FILE(APPEND "${TARGET_BUILD_FILE}" ${ARGN})
endmacro(write_target_build_file)

macro(add_target_library_path)
    unset(${this_target}_MYLSP_STRLIST)
    foreach(MYLSP ${ARGN})
        LIST(APPEND ${this_target}_MYLSP_STRLIST "-L${MYLSP}\n")
    endforeach(MYLSP)
    write_target_build_file("${this_target}_Multi2000_libs_gen" "${this_target}_validLibFile" ${${this_target}_MYLSP_STRLIST})
endmacro(add_target_library_path)

macro(add_target_libraries)
    unset(${this_target}_MYLIB_STRLIST)
    foreach(MYLIB ${ARGN})
        LIST(APPEND ${this_target}_MYLIB_STRLIST "-l${MYLIB}\n")
    endforeach(MYLIB)
    write_target_build_file("${this_target}_Multi2000_libs_gen" "${this_target}_validLibFile" ${${this_target}_MYLIB_STRLIST})
endmacro(add_target_libraries)

macro(add_target_custom_linkerflags)
    unset(${this_target}_MYCLF_STRLIST)
    foreach(MYCLF ${ARGN})
        LIST(APPEND ${this_target}_MYCLF_STRLIST "${MYCLF}\n")
    endforeach(MYCLF)
    write_target_build_file("${this_target}_Multi2000_libs_gen" "${this_target}_validLibFile" ${${this_target}_MYCLF_STRLIST})
endmacro(add_target_custom_linkerflags)

macro(add_target_includeDirs)
    unset(${this_target}_MYINC_STRLIST)
    foreach(MYINC ${ARGN})
        LIST(APPEND ${this_target}_MYINC_STRLIST "-I ${MYINC}\n")
    endforeach(MYINC)
    write_target_build_file("${this_target}_Multi2000_incs_gen" "${this_target}_validIncFile" ${${this_target}_MYINC_STRLIST})
endmacro(add_target_includeDirs)

macro(add_target_forcedIncludeFiles)
    unset(${this_target}_MYFIF_STRLIST)
    foreach(MYFIF ${ARGN})
        LIST(APPEND ${this_target}_MYFIF_STRLIST "-include \"${MYFIF}\"\n")
    endforeach(MYFIF)
    write_target_build_file("${this_target}_Multi2000_incs_gen" "${this_target}_validIncFile" ${${this_target}_MYFIF_STRLIST})
endmacro(add_target_forcedIncludeFiles)

macro(add_target_definitions)
    unset(${this_target}_MYDEF_STRLIST)
    foreach(MYDEF ${ARGN})
        target_compile_options(${this_target} PRIVATE $<$<CONFIG:Multi2000>:/D${MYDEF}>)  # add to msvc -> intellisense
        if(CMAKE_CROSSCOMPILING)
            add_definitions(${this_target} -D${MYDEF})
        endif()
        LIST(APPEND ${this_target}_MYDEF_STRLIST "-D${MYDEF}\n")
    endforeach(MYDEF)
    write_target_build_file("${this_target}_Multi2000_defs_gen" "${this_target}_validDefFile" ${${this_target}_MYDEF_STRLIST})
endmacro(add_target_definitions)


###
# set simulation libraries, include paths, definitions
macro(add_simulation_libraries)
    TARGET_LINK_LIBRARIES(${this_target} ${ARGN})
endmacro(add_simulation_libraries)

macro(add_simulation_includeDirs)
    INCLUDE_DIRECTORIES(${ARGN})
endmacro(add_simulation_includeDirs)

macro(add_simulation_forcedIncludeFiles)
    foreach(MYFIF ${ARGN})
        TARGET_COMPILE_OPTIONS(${this_target} PRIVATE $<$<OR:$<CONFIG:Debug>,$<CONFIG:Release>>:/FI${MYFIF}>)
    endforeach(MYFIF ${ARGN})
endmacro(add_simulation_forcedIncludeFiles)

macro(add_simulation_definitions)
    if(WIN32)
    foreach(MYDEF ${ARGN})
        TARGET_COMPILE_OPTIONS(${this_target} PRIVATE $<$<OR:$<CONFIG:Debug>,$<CONFIG:Release>>:/D${MYDEF}>)
    endforeach(MYDEF ${ARGN})
    endif()
endmacro(add_simulation_definitions)


###
# write target file list for each build configuration
macro(write_target_filelists)
    SET(FILELIST_OUTPUT_DIR ${this_root_dir}/tool/cmake/tmp)
    SET(FILELIST_SIMU       ${FILELIST_OUTPUT_DIR}/FilesSimu${this_target}.txt)
    SET(FILELIST_TARGET     ${FILELIST_OUTPUT_DIR}/FilesTarget${this_target}.txt)
    foreach(MYCFG "SIMU" "TARGET")
        LIST(APPEND ${this_target}_SOURCE_FILES_${MYCFG}      ${${this_target}_SOURCE_FILES})
        LIST(REMOVE_ITEM ${this_target}_SOURCE_FILES_${MYCFG} ${${this_target}_FILES_EXCLUDED_${MYCFG}})
        LIST(SORT ${this_target}_SOURCE_FILES_${MYCFG})
        UNSET(MYFILELIST_REL)
        foreach(MYFILE ${${this_target}_SOURCE_FILES_${MYCFG}})
            FILE(RELATIVE_PATH MYFILE ${this_root_dir} ${MYFILE})
            LIST(APPEND MYFILELIST_REL "${MYFILE}\n")
        endforeach(MYFILE)
        FILE(WRITE "${FILELIST_${MYCFG}}" ${MYFILELIST_REL})
    endforeach(MYCFG)
endmacro(write_target_filelists)

# evaluate a list of files and glob if there are * or ? within the file names
function(cds_search result)
  foreach(arg ${ARGN})
    # argument contains a globbing expression
    string(REGEX MATCH "[*?]+" query ${arg})
    if(query)
      file(GLOB found_files ${arg})
      list(APPEND sources ${found_files})
    else()
      list(APPEND sources ${arg})
    endif()
  endforeach()
  
  # path order
  IF(NOT "${sources}" STREQUAL "")
    foreach(source ${sources})
      get_filename_component(source ${source} ABSOLUTE)
      list(APPEND sources_path ${source})
    endforeach()
    list(REMOVE_DUPLICATES sources_path)
  ELSE()
    set(sources_path "")
  ENDIF()
  
  set(${result} ${sources_path} PARENT_SCOPE)
endfunction(cds_search)
